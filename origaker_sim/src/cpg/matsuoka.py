"""
Matsuoka Oscillator Implementation

This module implements the Matsuoka oscillator, a bio-inspired neural oscillator
based on mutual inhibition between two neurons with self-adaptation.

The Matsuoka oscillator consists of two mutually inhibiting neurons, each with
an adaptation mechanism that provides fatigue-like behavior.

References:
- Matsuoka, K. (1985). Sustained oscillations generated by mutually inhibiting 
  neurons with adaptation. Biological Cybernetics, 52(6), 367-376.
"""

import numpy as np
import matplotlib.pyplot as plt


class MatsuokaOscillator:
    """
    Bio-inspired Matsuoka oscillator with mutual inhibition and adaptation.
    
    The oscillator consists of two neurons (x1, x2) that mutually inhibit each other,
    with adaptation variables (v1, v2) that provide fatigue-like behavior leading
    to sustained oscillations.
    
    Dynamics:
        dx1/dt = (-x1 - w*y2 - beta*v1 + u) / tau
        dx2/dt = (-x2 - w*y1 - beta*v2 + u) / tau
        dv1/dt = (-v1 + y1) / tau_r
        dv2/dt = (-v2 + y2) / tau_r
        y1 = max(0, x1)
        y2 = max(0, x2)
    
    Parameters:
        tau (float): Time constant of the neurons. Controls the speed of neural dynamics.
                    Smaller values -> faster oscillations. Typical range: 0.1-2.0
        tau_r (float): Adaptation time constant. Controls adaptation speed.
                      Larger values -> slower adaptation -> longer oscillation periods.
                      Typical range: 1.0-10.0
        beta (float): Adaptation gain. Controls the strength of the fatigue effect.
                     Larger values -> stronger adaptation -> more pronounced oscillations.
                     Typical range: 1.0-5.0
        w (float): Mutual inhibition weight. Controls coupling strength between neurons.
                  Larger values -> stronger inhibition -> more stable oscillations.
                  Typical range: 1.0-5.0
        u (float): External tonic input. Provides baseline excitation to both neurons.
                  Must be positive for oscillations to occur. Typical range: 0.5-2.0
    
    State Variables:
        x1, x2 (float): Neural activities (can be negative)
        y1, y2 (float): Neural outputs (non-negative, y = max(0, x))
        v1, v2 (float): Adaptation variables (represent neural fatigue)
    """
    
    def __init__(self, tau=0.5, tau_r=1.0, beta=2.5, w=2.0, u=1.0):
        """
        Initialize the Matsuoka oscillator with given parameters.
        
        Args:
            tau (float): Neural time constant
            tau_r (float): Adaptation time constant  
            beta (float): Adaptation gain
            w (float): Mutual inhibition weight
            u (float): External tonic input
        """
        # Store parameters
        self.tau = tau
        self.tau_r = tau_r
        self.beta = beta
        self.w = w
        self.u = u
        
        # Initialize state variables
        self.reset()
    
    def reset(self):
        """
        Reset all state variables to zero.
        
        This initializes the oscillator to a resting state where both neurons
        are inactive and no adaptation has occurred.
        """
        self.x1 = 0.0
        self.x2 = 0.0
        self.v1 = 0.0
        self.v2 = 0.0
        
        # Compute initial outputs (non-negative)
        self.y1 = max(0.0, self.x1)
        self.y2 = max(0.0, self.x2)
    
    def step(self, dt=0.01):
        """
        Advance the oscillator state by one time step using explicit Euler integration.
        
        Args:
            dt (float): Time step size for integration. Smaller values give more
                       accurate results but require more computation. Typical: 0.001-0.01
        
        Returns:
            tuple: (y1, y2) - The neural outputs at the current time step
        """
        # Compute derivatives using current state
        dx1_dt = (-self.x1 - self.w * self.y2 - self.beta * self.v1 + self.u) / self.tau
        dx2_dt = (-self.x2 - self.w * self.y1 - self.beta * self.v2 + self.u) / self.tau
        dv1_dt = (-self.v1 + self.y1) / self.tau_r
        dv2_dt = (-self.v2 + self.y2) / self.tau_r
        
        # Update state variables using explicit Euler method
        self.x1 += dt * dx1_dt
        self.x2 += dt * dx2_dt
        self.v1 += dt * dv1_dt
        self.v2 += dt * dv2_dt
        
        # Compute outputs (ensure non-negativity)
        self.y1 = max(0.0, self.x1)
        self.y2 = max(0.0, self.x2)
        
        return self.y1, self.y2
    
    def get_state(self):
        """
        Get the current complete state of the oscillator.
        
        Returns:
            dict: Dictionary containing all state variables and outputs
        """
        return {
            'x1': self.x1, 'x2': self.x2,
            'v1': self.v1, 'v2': self.v2,
            'y1': self.y1, 'y2': self.y2
        }
    
    def set_parameters(self, **kwargs):
        """
        Update oscillator parameters.
        
        Args:
            **kwargs: Any of tau, tau_r, beta, w, u
        """
        for param, value in kwargs.items():
            if hasattr(self, param):
                setattr(self, param, value)
            else:
                raise ValueError(f"Unknown parameter: {param}")


def test_matsuoka_oscillator():
    """
    Test the Matsuoka oscillator and visualize its behavior.
    """
    # Create oscillator with default parameters
    osc = MatsuokaOscillator(tau=0.5, tau_r=1.0, beta=2.5, w=2.0, u=1.0)
    osc.reset()
    
    # Simulation parameters
    dt = 0.01
    total_time = 10.0
    steps = int(total_time / dt)
    
    # Storage for results
    time_points = []
    y1_values = []
    y2_values = []
    x1_values = []
    x2_values = []
    v1_values = []
    v2_values = []
    
    # Run simulation
    print("Running Matsuoka oscillator simulation...")
    for i in range(steps):
        y1, y2 = osc.step(dt)
        
        # Store results
        time_points.append(i * dt)
        y1_values.append(y1)
        y2_values.append(y2)
        state = osc.get_state()
        x1_values.append(state['x1'])
        x2_values.append(state['x2'])
        v1_values.append(state['v1'])
        v2_values.append(state['v2'])
    
    print(f"Simulation completed. Final outputs: y1={y1:.3f}, y2={y2:.3f}")
    
    # Create visualization
    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
    
    # Plot neural outputs
    axes[0].plot(time_points, y1_values, label='y1 (Neuron 1 output)', linewidth=2)
    axes[0].plot(time_points, y2_values, label='y2 (Neuron 2 output)', linewidth=2)
    axes[0].set_ylabel('Neural Output')
    axes[0].set_title('Matsuoka Oscillator - Neural Outputs')
    axes[0].legend()
    axes[0].grid(True, alpha=0.3)
    
    # Plot neural activities
    axes[1].plot(time_points, x1_values, label='x1 (Neuron 1 activity)', linewidth=2)
    axes[1].plot(time_points, x2_values, label='x2 (Neuron 2 activity)', linewidth=2)
    axes[1].set_ylabel('Neural Activity')
    axes[1].set_title('Neural Activities (can be negative)')
    axes[1].legend()
    axes[1].grid(True, alpha=0.3)
    
    # Plot adaptation variables
    axes[2].plot(time_points, v1_values, label='v1 (Adaptation 1)', linewidth=2)
    axes[2].plot(time_points, v2_values, label='v2 (Adaptation 2)', linewidth=2)
    axes[2].set_xlabel('Time (s)')
    axes[2].set_ylabel('Adaptation')
    axes[2].set_title('Adaptation Variables')
    axes[2].legend()
    axes[2].grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()
    
    return time_points, y1_values, y2_values


if __name__ == "__main__":
    # Example usage as specified in the task
    print("=== Matsuoka Oscillator Example Usage ===")
    
    # Create oscillator with specified parameters
    osc = MatsuokaOscillator(tau=0.5, tau_r=1.0, beta=2.5, w=2.0, u=1.0)
    osc.reset()
    
    # Run for 1000 steps as in the example
    print("Running oscillator for 1000 steps...")
    for i in range(1000):
        y1, y2 = osc.step(dt=0.01)
        
        # Print some intermediate results
        if i % 200 == 0:
            print(f"Step {i:4d}: y1={y1:.4f}, y2={y2:.4f}")
    
    print(f"Final state after 1000 steps: y1={y1:.4f}, y2={y2:.4f}")
    
    # Test with different parameters
    print("\n=== Testing Different Parameter Sets ===")
    
    # Faster oscillation (smaller tau)
    osc_fast = MatsuokaOscillator(tau=0.2, tau_r=1.0, beta=2.5, w=2.0, u=1.0)
    print("Fast oscillator (tau=0.2):")
    test_matsuoka_oscillator()
    
    # Parameter validation
    print("\n=== Parameter Guidelines ===")
    print("tau: Neural time constant (0.1-2.0) - smaller = faster oscillations")
    print("tau_r: Adaptation time constant (1.0-10.0) - larger = slower adaptation")
    print("beta: Adaptation gain (1.0-5.0) - larger = stronger fatigue effect") 
    print("w: Mutual inhibition (1.0-5.0) - larger = stronger coupling")
    print("u: Tonic input (0.5-2.0) - must be positive for oscillations")